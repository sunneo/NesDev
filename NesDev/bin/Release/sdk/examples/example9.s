;
; File generated by cc65 v 2.13.3
;
	.fopt		compiler,"cc65 v 2.13.3"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank, tmp1, ptr1, ptr2
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_col
	.import		_ppu_wait_nmi
	.import		_ppu_on_all
	.import		_scroll
	.import		_rand8
	.import		_set_vram_update
	.export		_main

.segment	"BSS"

_update_list:
	.res	36,$00

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"BSS"

L0004:
	.res	1,$00
L0005:
	.res	1,$00
L0006:
	.res	2,$00
L0007:
	.res	2,$00

.segment	"CODE"

;
; pal_col(1,0x30);//set while color
;
	lda     #$01
	jsr     pusha
	lda     #$30
	jsr     _pal_col
;
; y=0;
;
	lda     #$00
	sta     L0006
	sta     L0006+1
;
; update_list[0]=0x20|NT_UPD_HORZ;//horizontal update sequence, dummy address
;
	lda     #$60
	sta     _update_list
;
; update_list[1]=0x00;
;
	lda     #$00
	sta     _update_list+1
;
; update_list[2]=32;//update sequence is 32 tiles wide
;
	lda     #$20
	sta     _update_list+2
;
; update_list[3+32]=NT_UPD_EOF;
;
	lda     #$FF
	sta     _update_list+35
;
; set_vram_update(update_list);
;
	lda     #<(_update_list)
	ldx     #>(_update_list)
	jsr     _set_vram_update
;
; ppu_on_all();//enable rendering
;
	jsr     _ppu_on_all
;
; scroll(0,y);//scroll value will be applied on the next nmi
;
L001C:	jsr     push0
	lda     L0006
	ldx     L0006+1
	jsr     _scroll
;
; if(!(y&7))//put new row every 8 pixels
;
	lda     L0006
	and     #$07
	jne     L0045
;
; row=(y>>3)+59;//get row number for update, it is shifted just above the visible part of the screen
;
	lda     L0006
	ldx     L0006+1
	jsr     asrax3
	clc
	adc     #$3B
	sta     L0005
;
; if(row>=60) row-=60;//keep the row number within the limits
;
	cmp     #$3C
	bcc     L0029
	lda     L0005
	sec
	sbc     #$3C
	sta     L0005
;
; adr=row<<5;//convert Y from pixels to tiles (row=y/8), then to nametable offset (offset=row*32)
;
L0029:	ldx     #$00
	lda     L0005
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ldx     tmp1
	sta     L0007
	stx     L0007+1
;
; if(adr<960) adr=adr|NAMETABLE_A; else adr=(adr-960)|NAMETABLE_C;//add base address of one of two nametables
;
	cpx     #$03
	bne     L0031
	cmp     #$C0
L0031:	bcs     L002F
	lda     L0007
	sta     L0007
	lda     L0007+1
	ora     #$20
	jmp     L005B
L002F:	lda     L0007
	sec
	sbc     #$C0
	sta     L0007
	lda     L0007+1
	sbc     #$03
	ora     #$28
L005B:	sta     L0007+1
;
; update_list[0]=MSB(adr)|NT_UPD_HORZ;//set the address
;
	ora     #$40
	sta     _update_list
;
; update_list[1]=LSB(adr);
;
	lda     L0007
	sta     _update_list+1
;
; for(i=0;i<32;++i) update_list[3+i]=0x10+(rand8()&7);//fill row buffer with random tiles
;
	lda     #$00
	sta     L0004
L0044:	lda     L0004
	cmp     #$20
	bcs     L0045
	ldx     #$00
	lda     L0004
	clc
	adc     #$03
	bcc     L005A
	inx
	clc
L005A:	adc     #<(_update_list)
	tay
	txa
	adc     #>(_update_list)
	tax
	tya
	jsr     pushax
	jsr     _rand8
	and     #$07
	clc
	adc     #$10
	ldy     #$00
	jsr     staspidx
	inc     L0004
	jmp     L0044
;
; --y;//next pixel
;
L0045:	lda     L0006
	sec
	sbc     #$01
	sta     L0006
	bcs     L0053
	dec     L0006+1
;
; if(y<0) y=240*2-1;//keep Y within the total height of two nametables
;
L0053:	ldx     L0006+1
	cpx     #$80
	bcc     L0054
	ldx     #$01
	lda     #$DF
	sta     L0006
	stx     L0006+1
;
; ppu_wait_nmi();
;
L0054:	jsr     _ppu_wait_nmi
;
; }
;
	jmp     L001C

.endproc

